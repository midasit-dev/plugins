// SPGAllOther Converter - Class150_SPGAllOther equivalent
// Parses other spring types (名古屋高速ゴム支承, BMR(CD)ダンパー) to store in context
// Actual MCT output is generated by SPGAllSymConverter
// Based on VBA Class150_SPGAllOther (lines 12-18 for column structure)

import { ConversionContext, SpringComponentData } from '../types/converter.types';
import { safeParseNumber } from '../utils/unitConversion';

export interface SPGAllOtherResult {
  mctLines: string[];
  hasDamper: boolean;
}

export interface OtherSpringTableData {
  nagoyaData: (string | number)[][];
  bmrData: (string | number)[][];
}

// Column offsets for each table (relative to main SPG_ALL_OTHER startCol=2)
// Based on VBA nRead*STCol and nRead*EDCol
const TABLE_OFFSETS = {
  NAGOYA: { start: 0, end: 10 },   // cols 2-12 → 0-10 (11 cols)
  BMR: { start: 12, end: 23 },     // cols 14-25 → 12-23 (12 cols)
};

/**
 * Extract table data from combined raw data
 */
function extractTableData(
  rawData: (string | number)[][],
  startCol: number,
  endCol: number
): (string | number)[][] {
  return rawData.map(row => {
    const tableRow: (string | number)[] = [];
    for (let i = startCol; i <= endCol && i < row.length; i++) {
      tableRow.push(row[i] ?? '');
    }
    return tableRow;
  }).filter(row => row[0] !== undefined && String(row[0]).trim() !== '');
}

/**
 * Parse other spring data from combined raw data
 * Extracts 2 table regions and populates context.springCompData
 */
function parseOtherSpringFromRawData(
  rawData: (string | number)[][],
  context: ConversionContext
): boolean {
  // Extract 2 table regions from combined data
  const nagoyaData = extractTableData(rawData, TABLE_OFFSETS.NAGOYA.start, TABLE_OFFSETS.NAGOYA.end);
  const bmrData = extractTableData(rawData, TABLE_OFFSETS.BMR.start, TABLE_OFFSETS.BMR.end);

  // Parse each table
  parseNagoyaTable(nagoyaData, context);
  const hasDamper = parseBmrTable(bmrData, context);

  return hasDamper;
}

/**
 * Parse 名古屋高速ゴム支承 table data (Table 1: 11 columns B~L)
 * VBA Class150_SPGAllOther nRead1STCol=2, nRead1EDCol=12
 *
 * Column structure:
 * 0: Property name (ばね特性表示名)
 * 1: Component (xl, yl, zl, rxl, ryl, rzl)
 * 2: Bearing type (H15.10 HDR-G12, etc.)
 * 3: Rubber height (mm)
 * 4: Area (mm²)
 * 5-10: Additional data
 */
function parseNagoyaTable(data: (string | number)[][], context: ConversionContext): void {
  for (const row of data) {
    if (!row[0] || String(row[0]).trim() === '') continue;

    const propName = String(row[0]);
    const componentStr = String(row[1] || '');
    const componentIdx = getComponentIndex(componentStr);

    // Get bearing data - convert units to match VBA GetSpringData
    const bearingType = String(row[2] || '');
    const rubberHeight = safeParseNumber(row[3]) / 1000;      // mm → m (VBA ChangeMM_M)
    const area = safeParseNumber(row[4]) / 1000000;           // mm² → m² (VBA ChangeMM2_M2)

    // Store as LITR type in springCompData
    updateSpringCompData(
      context,
      propName,
      componentIdx,
      'LITR',
      [bearingType, String(rubberHeight), String(area)]
    );
  }
}

/**
 * Parse BMR(CD)ダンパー table data (Table 2: 12 columns N~Y)
 * VBA Class150_SPGAllOther nRead2STCol=14, nRead2EDCol=25
 *
 * Column structure:
 * 0: Property name
 * 1: Component
 * 2: Damper type
 * 3: C (damping coefficient)
 * 4: Alpha (velocity exponent)
 * 5-11: Additional data
 */
function parseBmrTable(data: (string | number)[][], context: ConversionContext): boolean {
  let hasDamper = false;

  for (const row of data) {
    if (!row[0] || String(row[0]).trim() === '') continue;

    hasDamper = true;
    const propName = String(row[0]);
    const componentStr = String(row[1] || '');
    const componentIdx = getComponentIndex(componentStr);

    // Get damper data
    const damperType = String(row[2] || 'BMR(CD)ダンパー');
    const c = safeParseNumber(row[3]);
    const alpha = safeParseNumber(row[4]);

    // Store as VISCOUS-OIL-DAMPER type in springCompData
    updateSpringCompData(
      context,
      propName,
      componentIdx,
      'VISCOUS-OIL-DAMPER',
      [damperType, String(c), String(alpha)]
    );
  }

  return hasDamper;
}

/**
 * Get component index from string (1-6)
 * VBA dicComponent mapping:
 *   "xl" -> 1, "yl" -> 2, "zl" -> 3
 *   "θxl" -> 4, "θyl" -> 5, "θzl" -> 6
 *
 * CRITICAL: Must check rotational DOFs first because 'θxl'.includes('xl') is true!
 */
function getComponentIndex(componentStr: string): number {
  const str = componentStr.trim();
  const strLower = str.toLowerCase();

  // Check for rotational DOFs FIRST (order matters!)
  // VBA uses θ (theta) character, also check for common variations
  if (str.includes('θxl') || str.includes('θXl') || str.includes('ΘXL') ||
      strLower.includes('θxl') || str.includes('回xl') || strLower.includes('rxl') ||
      str.includes('θx') || str.includes('Θx')) return 4;
  if (str.includes('θyl') || str.includes('θYl') || str.includes('ΘYL') ||
      strLower.includes('θyl') || str.includes('回yl') || strLower.includes('ryl') ||
      str.includes('θy') || str.includes('Θy')) return 5;
  if (str.includes('θzl') || str.includes('θZl') || str.includes('ΘZL') ||
      strLower.includes('θzl') || str.includes('回zl') || strLower.includes('rzl') ||
      str.includes('θz') || str.includes('Θz')) return 6;

  // Check for linear DOFs (after rotational to avoid false matches)
  if (strLower.includes('xl')) return 1;
  if (strLower.includes('yl')) return 2;
  if (strLower.includes('zl')) return 3;

  const num = parseInt(str, 10);
  if (num >= 1 && num <= 6) return num;

  return 1;
}

/**
 * Update springCompData with other type data
 */
function updateSpringCompData(
  context: ConversionContext,
  propName: string,
  componentIdx: number,
  hystType: string,
  data: string[]
): void {
  let sprData = context.springCompData.get(propName);

  if (!sprData) {
    sprData = { components: [] };
    context.springCompData.set(propName, sprData);
  }

  let comp = sprData.components.find(c => c.componentIndex === componentIdx);
  if (!comp) {
    comp = {
      componentIndex: componentIdx,
      componentType: 2, // Other type
      subType: 0,
      propertyName: propName,
      rotate: 0,
      mctHyst: hystType,
      mctHyst2: '',
      mctSym: 0,
      mctType: 0,
      mctSFType: 0,
      mctStiff: 0,
      category: [hystType],
      data: data,
    };
    sprData.components.push(comp);
  } else {
    comp.mctHyst = hystType;
    comp.data = data;
    comp.componentType = 2;
  }
}

/**
 * Convert other spring types - parses data into context
 * Actual MCT output is generated by SPGAllSymConverter
 * Based on VBA Class150_SPGAllOther
 */
export function convertOtherSprings(
  rawData: (string | number)[][],
  context: ConversionContext,
  spg6CompMapping: Map<string, number>
): SPGAllOtherResult {
  const mctLines: string[] = [];
  let hasDamper = false;

  // Parse raw data into context.springCompData if provided
  if (rawData && rawData.length > 0) {
    hasDamper = parseOtherSpringFromRawData(rawData, context);
  }

  // Note: Actual MCT output for LITR and VISCOUS-OIL-DAMPER
  // is generated by SPGAllSymConverter, not here.
  // This converter only parses data and stores in context.

  return { mctLines, hasDamper };
}

/**
 * Convert with 2 separate table data arrays
 */
export function convertOtherSpringsWithTables(
  tableData: OtherSpringTableData,
  context: ConversionContext,
  spg6CompMapping: Map<string, number>
): SPGAllOtherResult {
  // Parse nagoya table
  parseNagoyaTable(tableData.nagoyaData, context);
  // Parse BMR table
  const hasDamper = parseBmrTable(tableData.bmrData, context);

  return { mctLines: [], hasDamper };
}
