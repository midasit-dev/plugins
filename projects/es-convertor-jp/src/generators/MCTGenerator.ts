// MCT Generator - generates MCT output from converted data

import {
  ConversionResult,
  ConversionOptions,
  createConversionContext,
  ProgressCallback,
} from '../types/converter.types';
import { SHEET_NAMES } from '../constants/sheetNames';
import { UNIT_SETTINGS } from '../constants/mctKeywords';
import { ParseResult, getSheetDataForConversion, hasSheet } from '../parsers/ExcelParser';

// Import converters
import { convertNodes } from '../converters/NodeConverter';
import { convertMaterials } from '../converters/MaterialConverter';
import { convertFrames, setElementNumbers, readFrameSectionNames } from '../converters/FrameConverter';
import { convertPlaneElements } from '../converters/PlnElmConverter';
import { convertRigid, readRigidData } from '../converters/RigidConverter';
import { parseNumbSectData } from '../converters/SectElemConverter';
import { convertSections } from '../converters/SectConverter';
import { convertPlnSections } from '../converters/PlnSectConverter';
import { convertHingeProperties, readHingeProperties } from '../converters/HingePropConverter';
import { convertHingeAssignments } from '../converters/HingeAssConverter';
import { convertSpringElements, getSpringDoublePoints } from '../converters/ElemSpringConverter';
import { parseSPG6CompData } from '../converters/SPG6CompConverter';
import { convertSymmetricSprings, convertSymmetricSpringsWithTables, parseSymmetricSpringTables } from '../converters/SPGAllSymConverter';
import { convertAsymmetricSprings, convertAsymmetricSpringsWithTables, parseAsymmetricSpringTables } from '../converters/SPGAllASymConverter';
import { convertOtherSprings, convertOtherSpringsWithTables } from '../converters/SPGAllOtherConverter';
import { convertFulcrum } from '../converters/FulcrumConverter';
import { convertFulcrumDetail } from '../converters/FulcDetailConverter';
import { convertNodalMass } from '../converters/NodalMassConverter';
import { convertLoads } from '../converters/LoadConverter';
import { convertInternalForce } from '../converters/InternalForceConverter';

/**
 * Generate MCT output from parsed Excel data
 */
export async function generateMCT(
  parseResult: ParseResult,
  options: ConversionOptions = { version: 2025, includeComments: true, validateInput: true },
  onProgress?: ProgressCallback
): Promise<ConversionResult> {
  const errors: string[] = [];
  const warnings: string[] = [];
  const mctLines: string[] = [];

  const version = options.version || 2025;
  const context = createConversionContext(version);
  const sheets = parseResult.sheets;

  try {
    // Progress tracking
    const report = (progress: number, message: string) => {
      if (onProgress) onProgress(progress, message);
    };

    report(0, '変換を開始します...');

    // Debug: Log sheet data counts
    console.log('=== MCT Generator Debug ===');
    console.log('--- Sheets ---');
    for (const [name, sheet] of sheets) {
      console.log(`Sheet "${name}": ${sheet.data.length} rows`);
    }
    console.log('--- SubTables ---');
    for (const [name, data] of parseResult.subTables) {
      console.log(`SubTable "${name}": ${data.length} rows`);
    }

    // Add header with version info
    mctLines.push(`; MIDAS/CIVIL NX ${version} Text Data File`);
    mctLines.push(`; Generated by ES-to-MIDAS Convertor (v1.1)`);
    mctLines.push(`*UNIT    ; Unit System`);
    mctLines.push(`; FORCE, LENGTH, HEAT, TEMPER`);
    mctLines.push(`${UNIT_SETTINGS.FORCE},${UNIT_SETTINGS.LENGTH},${UNIT_SETTINGS.HEAT},${UNIT_SETTINGS.TEMPERATURE}`);
    mctLines.push('');

    // Step 1: Parse numbered sections first (for section-material mapping)
    report(5, '数値断面を解析中...');
    if (hasSheet(sheets, SHEET_NAMES.NUMB_SECT)) {
      const numbSectData = getSheetDataForConversion(sheets, SHEET_NAMES.NUMB_SECT);
      parseNumbSectData(numbSectData, context);
    }

    // Step 2: Get spring double points (for node processing)
    let doublePointNodes = new Set<string>();
    if (hasSheet(sheets, SHEET_NAMES.ELEM_SPRING)) {
      const springData = getSheetDataForConversion(sheets, SHEET_NAMES.ELEM_SPRING);
      doublePointNodes = getSpringDoublePoints(springData);
    }

    // Step 3: Convert nodes
    report(10, '節点を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.NODE)) {
      const nodeData = getSheetDataForConversion(sheets, SHEET_NAMES.NODE);
      const nodeResult = convertNodes(
        nodeData.map(row => ({
          id: String(row[0]),
          x: Number(row[1]) || 0,
          y: Number(row[2]) || 0,
          z: Number(row[3]) || 0,
        })),
        context,
        doublePointNodes
      );
      mctLines.push(...nodeResult.mctLines);
      mctLines.push('');
    } else {
      errors.push('節点座標シートがありません');
      return { success: false, mctData: null, mctText: '', errors, warnings };
    }

    // Step 4: Collect section names from frame elements
    report(15, 'フレーム要素の断面を解析中...');
    const sectionNames = new Map<string, boolean>();
    let frameData: (string | number)[][] = [];
    if (hasSheet(sheets, SHEET_NAMES.FRAME)) {
      frameData = getSheetDataForConversion(sheets, SHEET_NAMES.FRAME);
      readFrameSectionNames(frameData, context);

      // Collect section names
      for (const row of frameData) {
        if (row[4]) sectionNames.set(String(row[4]), true);
        if (row[5]) sectionNames.set(String(row[5]), true);
      }
    }

    // Step 5: Read section element names
    if (hasSheet(sheets, SHEET_NAMES.SECT_ELEM)) {
      const sectElemData = getSheetDataForConversion(sheets, SHEET_NAMES.SECT_ELEM);
      for (const row of sectElemData) {
        if (row[0]) context.sect2Material.set(String(row[0]), String(row[1] || ''));
      }
    }

    // Step 6: Convert materials (data preparation)
    report(20, '材料を変換中...');
    let matResultLines: string[] = [];
    if (hasSheet(sheets, SHEET_NAMES.MATERIAL)) {
      const materialData = getSheetDataForConversion(sheets, SHEET_NAMES.MATERIAL);
      const matResult = convertMaterials(
        materialData.map(row => ({
          name: String(row[0]),
          type: String(row[1] || ''),
          category: String(row[2] || ''),
          strength: Number(row[3]) || 0,
          elasticModulus: Number(row[4]) || 0,
          density: Number(row[5]) || 0,
          thermalCoeff: Number(row[6]) || 0,
        })),
        context
      );
      matResultLines = matResult.mctLines;
    }

    // Step 7: Convert sections (data preparation)
    report(30, '断面を変換中...');
    let sectResultValue: string[] = [];
    let sectResultTapered: string[] = [];
    if (hasSheet(sheets, SHEET_NAMES.SECT)) {
      const sectData = getSheetDataForConversion(sheets, SHEET_NAMES.SECT);
      const sectYoung = new Map<string, number>();

      // Build section pairs from frame data
      const sectionPairs = new Map<string, string[]>();
      for (const row of frameData) {
        const iSect = String(row[4] || '');
        const jSect = String(row[5] || iSect);
        if (!iSect) continue;

        if (!sectionPairs.has(iSect)) {
          sectionPairs.set(iSect, []);
        }
        const existing = sectionPairs.get(iSect)!;
        if (!existing.includes(jSect)) {
          existing.push(jSect);
        }
      }

      const sectResult = convertSections(sectData, context, sectionPairs, sectYoung);
      sectResultValue = sectResult.mctLinesValue;
      sectResultTapered = sectResult.mctLinesTapered;
    }

    // Step 8: Convert plane sections (data preparation)
    let plnSectMapping = new Map<string, { sectNo: number; materialName: string }>();
    let plnSectLines: string[] = [];
    if (hasSheet(sheets, SHEET_NAMES.PLN_SECT)) {
      const plnSectData = getSheetDataForConversion(sheets, SHEET_NAMES.PLN_SECT);
      console.log('PLN_SECT data rows:', plnSectData.length);
      const plnSectResult = convertPlnSections(plnSectData, context);
      plnSectMapping = plnSectResult.plnSectMapping;
      plnSectLines = plnSectResult.mctLines;
    }

    // Step 9: Set element numbers (including rigid elements)
    report(40, '要素番号を設定中...');
    let rigidData: (string | number)[][] = [];
    if (hasSheet(sheets, SHEET_NAMES.RIGID)) {
      rigidData = readRigidData(getSheetDataForConversion(sheets, SHEET_NAMES.RIGID));
    }
    if (frameData.length > 0) {
      setElementNumbers(frameData, context, rigidData);
    }

    // Step 10: Convert frame elements
    report(45, 'フレーム要素を変換中...');
    console.log('Frame data rows:', frameData.length);
    let frameResultLines: string[] = [];
    if (frameData.length > 0) {
      const frameResult = convertFrames(frameData, context);
      console.log('Frame result mctLines:', frameResult.mctLines.length);
      frameResultLines = frameResult.mctLines;
    }

    // Step 11: Convert plane elements
    let plnElmResultLines: string[] = [];
    if (hasSheet(sheets, SHEET_NAMES.PLANE_ELEMENT)) {
      const plnElmData = getSheetDataForConversion(sheets, SHEET_NAMES.PLANE_ELEMENT);
      console.log('PLANE_ELEMENT data rows:', plnElmData.length);
      const plnElmResult = convertPlaneElements(
        plnElmData,
        context,
        plnSectMapping
      );
      plnElmResultLines = plnElmResult.mctLines;
    }

    // Step 12: Convert rigid elements
    report(50, '剛体要素を変換中...');
    console.log('Rigid data rows:', rigidData.length);
    let rigidResultLines: string[] = [];
    let rigidResultConstraintLines: string[] = [];
    if (rigidData.length > 0) {
      const rigidResult = convertRigid(rigidData, context);
      console.log('Rigid result mctLinesRigid:', rigidResult.mctLinesRigid.length);
      rigidResultLines = rigidResult.mctLinesRigid;
      rigidResultConstraintLines = rigidResult.mctLinesConstraint || [];
    }

    // === Output order: ELEMENT → MATERIAL → SECTION/THICKNESS (VBA order) ===

    // Output FRAME elements
    if (frameResultLines.length > 0) {
      mctLines.push(...frameResultLines);
      mctLines.push('');
    }

    // Output PLANE elements
    if (plnElmResultLines.length > 2) {
      mctLines.push(...plnElmResultLines);
      mctLines.push('');
    }

    // Output RIGID elements
    if (rigidResultLines.length > 2) {
      mctLines.push(...rigidResultLines);
      mctLines.push('');
    }

    // Output MATERIAL
    if (matResultLines.length > 0) {
      mctLines.push(...matResultLines);
      mctLines.push('');
    }

    // Output SECTION (VALUE)
    if (sectResultValue.length > 6) {
      mctLines.push(...sectResultValue);
      mctLines.push('');
    }

    // Output SECTION (TAPERED)
    if (sectResultTapered.length > 11) {
      mctLines.push(...sectResultTapered);
      mctLines.push('');
    }

    // Output THICKNESS (plane sections)
    if (plnSectLines.length > 1) {
      mctLines.push(...plnSectLines);
      mctLines.push('');
    }

    // Step 13: Convert hinge properties and assignments
    report(60, 'ヒンジ特性を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.HINGE_PROP)) {
      // Get both zp and yp data
      const hingePropZpData = getSheetDataForConversion(sheets, SHEET_NAMES.HINGE_PROP);
      const hingePropYpData = hasSheet(sheets, 'HINGE_PROP_YP')
        ? getSheetDataForConversion(sheets, 'HINGE_PROP_YP')
        : [];
      const hingeMapping = readHingeProperties(hingePropZpData, context);

      if (hasSheet(sheets, SHEET_NAMES.HINGE_ASS)) {
        const hingeAssData = getSheetDataForConversion(sheets, SHEET_NAMES.HINGE_ASS);
        const hingeAssResult = convertHingeAssignments(hingeAssData, context, hingeMapping);

        const hingePropResult = convertHingeProperties(
          hingePropZpData,
          hingePropYpData,
          context,
          hingeAssResult.hystYp,
          hingeAssResult.hystZp,
          hingeAssResult.hingeElements
        );

        if (hingePropResult.mctLines.length > 2) {
          mctLines.push(...hingePropResult.mctLines);
          mctLines.push('');
        }

        // IHINGE-ASSIGN is generated by HingePropConverter (not HingeAssConverter)
        if (hingePropResult.mctLinesAssign.length > 2) {
          mctLines.push(...hingePropResult.mctLinesAssign);
          mctLines.push('');
        }
      }
    }

    // Step 14: Convert spring elements
    report(70, 'ばね要素を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.SPG_6COMP)) {
      const spg6Data = getSheetDataForConversion(sheets, SHEET_NAMES.SPG_6COMP);
      const spg6Result = parseSPG6CompData(spg6Data, context);

      // Get all spring subTable data
      const spgSymLinear = parseResult.subTables.get('SPG_ALL_SYM_LINEAR') || [];
      const spgSymBilinear = parseResult.subTables.get('SPG_ALL_SYM_BILINEAR') || [];
      const spgSymTrilinear = parseResult.subTables.get('SPG_ALL_SYM_TRILINEAR') || [];
      const spgSymTetralinear = parseResult.subTables.get('SPG_ALL_SYM_TETRALINEAR') || [];
      const spgAsymBilinear = parseResult.subTables.get('SPG_ALL_ASYM_BILINEAR') || [];
      const spgAsymTrilinear = parseResult.subTables.get('SPG_ALL_ASYM_TRILINEAR') || [];
      const spgAsymTetralinear = parseResult.subTables.get('SPG_ALL_ASYM_TETRALINEAR') || [];

      // Debug: Log subTable sizes
      console.log('=== SPG_ALL_SYM subTables ===');
      console.log('SYM LINEAR rows:', spgSymLinear.length);
      console.log('SYM BILINEAR rows:', spgSymBilinear.length);
      console.log('SYM TRILINEAR rows:', spgSymTrilinear.length);
      console.log('SYM TETRALINEAR rows:', spgSymTetralinear.length);
      console.log('ASYM BILINEAR rows:', spgAsymBilinear.length);
      console.log('ASYM TRILINEAR rows:', spgAsymTrilinear.length);
      console.log('ASYM TETRALINEAR rows:', spgAsymTetralinear.length);

      // STEP 1: Parse ALL detail tables FIRST to populate springCompData with stiffness values
      // This must happen BEFORE ElemSpring conversion so that ~1, ~2 properties can copy data
      //
      // IMPORTANT: VBA parsing order is SYMMETRIC first, ASYMMETRIC second!
      // VBA: vCls(0)=SPGAllSym, vCls(1)=SPGAllASym, vCls(2)=SPGAllOther
      // When same property exists in both sheets, ASYMMETRIC data OVERWRITES symmetric data.

      // Parse SYMMETRIC data FIRST (VBA i=0)
      if (spgSymLinear.length > 0 || spgSymBilinear.length > 0 ||
          spgSymTrilinear.length > 0 || spgSymTetralinear.length > 0) {
        parseSymmetricSpringTables(
          {
            linearData: spgSymLinear,
            bilinearData: spgSymBilinear,
            trilinearData: spgSymTrilinear,
            tetralinearData: spgSymTetralinear,
          },
          context
        );
      }

      // Parse ASYMMETRIC data SECOND (VBA i=1) - OVERWRITES symmetric data if exists
      if (spgAsymBilinear.length > 0 || spgAsymTrilinear.length > 0 ||
          spgAsymTetralinear.length > 0) {
        parseAsymmetricSpringTables(
          {
            bilinearData: spgAsymBilinear,
            trilinearData: spgAsymTrilinear,
            tetralinearData: spgAsymTetralinear,
          },
          context
        );
      }

      // Parse OTHER spring data THIRD (VBA i=2) - must be before NL-PROP generation
      // so that LITR/VISCOUS-OIL-DAMPER data is included in NL-PROP output
      const spgOtherNagoya = parseResult.subTables.get('SPG_ALL_OTHER_NAGOYA') || [];
      const spgOtherBmr = parseResult.subTables.get('SPG_ALL_OTHER_BMR') || [];
      if (spgOtherNagoya.length > 0 || spgOtherBmr.length > 0) {
        convertOtherSpringsWithTables(
          {
            nagoyaData: spgOtherNagoya,
            bmrData: spgOtherBmr,
          },
          context,
          spg6Result.spg6CompMapping
        );
      }

      // STEP 2: Now convert ElemSpring - at this point springCompData has full data
      // so ~1, ~2 properties will have complete data copied from originals
      if (hasSheet(sheets, SHEET_NAMES.ELEM_SPRING)) {
        const springElmData = getSheetDataForConversion(sheets, SHEET_NAMES.ELEM_SPRING);
        const springResult = convertSpringElements(springElmData, context, spg6Result.spg6CompMapping);
        if (springResult.mctLines.length > 2) {
          mctLines.push(...springResult.mctLines);
          mctLines.push('');
        }
      }

      // STEP 3: Generate NL-PROP output using ALL properties (including ~1, ~2)
      if (spgSymLinear.length > 0 || spgSymBilinear.length > 0 ||
          spgSymTrilinear.length > 0 || spgSymTetralinear.length > 0 ||
          spgAsymBilinear.length > 0 || spgAsymTrilinear.length > 0 ||
          spgAsymTetralinear.length > 0 ||
          context.springCompData.size > 0) {
        // Generate NL-PROP without re-parsing (data already in springCompData)
        const symResult = convertSymmetricSprings([], context, spg6Result.spg6CompMapping);
        if (symResult.mctLines.length > 2) {
          mctLines.push(...symResult.mctLines);
          mctLines.push('');
        }
        // Add oil damper section if present (VBA VISCOUS-OIL-DAMPER)
        if (symResult.oilDamperLines.length > 0) {
          mctLines.push(...symResult.oilDamperLines);
          mctLines.push('');
        }
      }

      // Generate IHINGE-PROP for spring properties
      // Note: This is separate from NL-PROP and uses a different MCT format
      // IMPORTANT: Use convertAsymmetricSprings with empty array to avoid re-parsing
      // The data is already in springCompData from earlier parsing steps
      // This includes BOTH symmetric and asymmetric component data
      if (context.springCompData.size > 0) {
        const asymResult = convertAsymmetricSprings(
          [],  // Don't re-parse, use existing springCompData
          context,
          spg6Result.spg6CompMapping
        );
        if (asymResult.mctLines.length > 13) {  // More than just comments
          mctLines.push(...asymResult.mctLines);
          mctLines.push('');
        }
      }

      // Other springs warning (parsing already done above, before NL-PROP generation)
      if (spgOtherBmr.length > 0) {
        warnings.push('BMR(CD)ダンパーはCIVIL NXの粘性ダンパーに変換されます。プロパティはデータ変換後に手動で変更してください。');
      }
    }

    // Step 15: Convert supports (fulcrum)
    report(80, '支点を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.FULCRUM)) {
      const fulcrumData = getSheetDataForConversion(sheets, SHEET_NAMES.FULCRUM);
      const fulcrumResult = convertFulcrum(fulcrumData, context);

      if (fulcrumResult.mctLinesGSpring.length > 2) {
        mctLines.push(...fulcrumResult.mctLinesGSpring);
        mctLines.push('');

        // Convert fulcrum details
        if (hasSheet(sheets, SHEET_NAMES.FULC_DETAIL)) {
          const detailData = getSheetDataForConversion(sheets, SHEET_NAMES.FULC_DETAIL);
          const detailResult = convertFulcrumDetail(detailData, context, fulcrumResult.springTypeMapping);
          if (detailResult.mctLines.length > 2) {
            mctLines.push(...detailResult.mctLines);
            mctLines.push('');
          }
        }
      }

      if (fulcrumResult.mctLinesConstraint.length > 2) {
        mctLines.push(...fulcrumResult.mctLinesConstraint);
        mctLines.push('');
      }
    }

    // Step 16: Convert nodal masses
    report(85, '節点質量を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.NODAL_MASS)) {
      const massData = getSheetDataForConversion(sheets, SHEET_NAMES.NODAL_MASS);
      const massResult = convertNodalMass(massData, context);
      if (massResult.mctLines.length > 2) {
        mctLines.push(...massResult.mctLines);
        mctLines.push('');
      }
    }

    // Step 17: Convert internal forces (INI-EFORCE before LOAD)
    report(90, '内力を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.INTERNAL_FORCE)) {
      const forceData = getSheetDataForConversion(sheets, SHEET_NAMES.INTERNAL_FORCE);
      const forceResult = convertInternalForce(forceData, context);
      if (forceResult.mctLines.length > 2) {
        mctLines.push(...forceResult.mctLines);
        mctLines.push('');
      }
    }

    // Step 18: Convert loads
    report(95, '荷重を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.LOAD)) {
      const loadData = getSheetDataForConversion(sheets, SHEET_NAMES.LOAD);
      const loadResult = convertLoads(loadData, context);

      if (loadResult.mctLinesLoadCase.length > 2) {
        mctLines.push(...loadResult.mctLinesLoadCase);
        mctLines.push('');
      }
      if (loadResult.mctLinesConLoad.length > 2) {
        mctLines.push(...loadResult.mctLinesConLoad);
        mctLines.push('');
      }
      if (loadResult.mctLinesSpDisp.length > 2) {
        mctLines.push(...loadResult.mctLinesSpDisp);
        mctLines.push('');
      }
      if (loadResult.mctLinesBeamLoad.length > 2) {
        mctLines.push(...loadResult.mctLinesBeamLoad);
        mctLines.push('');
      }
      if (loadResult.mctLinesElTemper.length > 2) {
        mctLines.push(...loadResult.mctLinesElTemper);
        mctLines.push('');
      }
    }

    // Rigid CONSTRAINT output (after LOAD/ELTEMPER section)
    if (rigidResultConstraintLines.length > 0) {
      mctLines.push(...rigidResultConstraintLines);
      mctLines.push('');
    }

    // Add end marker
    mctLines.push('*ENDDATA');

    report(100, '変換完了');

    const mctText = mctLines.join('\n');

    return {
      success: true,
      mctData: null, // Full MCTData structure not needed for text output
      mctText,
      errors,
      warnings,
    };
  } catch (error) {
    errors.push(`変換エラー: ${error}`);
    return {
      success: false,
      mctData: null,
      mctText: '',
      errors,
      warnings,
    };
  }
}

/**
 * Download MCT text as file
 */
export function downloadMCT(mctText: string, filename: string = 'output.mct'): void {
  const blob = new Blob([mctText], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
