// MCT Generator - generates MCT output from converted data

import {
  ConversionResult,
  ConversionOptions,
  createConversionContext,
  ProgressCallback,
} from '../types/converter.types';
import { SHEET_NAMES } from '../constants/sheetNames';
import { UNIT_SETTINGS } from '../constants/mctKeywords';
import { ParseResult, getSheetDataForConversion, hasSheet } from '../parsers/ExcelParser';

// Import converters
import { convertNodes } from '../converters/NodeConverter';
import { convertMaterials } from '../converters/MaterialConverter';
import { convertFrames, setElementNumbers, readFrameSectionNames } from '../converters/FrameConverter';
import { convertPlaneElements } from '../converters/PlnElmConverter';
import { convertRigid, readRigidData } from '../converters/RigidConverter';
import { parseNumbSectData } from '../converters/SectElemConverter';
import { convertSections } from '../converters/SectConverter';
import { convertPlnSections } from '../converters/PlnSectConverter';
import { convertHingeProperties, readHingeProperties } from '../converters/HingePropConverter';
import { convertHingeAssignments } from '../converters/HingeAssConverter';
import { convertSpringElements, getSpringDoublePoints } from '../converters/ElemSpringConverter';
import { parseSPG6CompData } from '../converters/SPG6CompConverter';
import { convertSymmetricSprings } from '../converters/SPGAllSymConverter';
import { convertAsymmetricSprings } from '../converters/SPGAllASymConverter';
import { convertOtherSprings } from '../converters/SPGAllOtherConverter';
import { convertFulcrum } from '../converters/FulcrumConverter';
import { convertFulcrumDetail } from '../converters/FulcDetailConverter';
import { convertNodalMass } from '../converters/NodalMassConverter';
import { convertLoads } from '../converters/LoadConverter';
import { convertInternalForce } from '../converters/InternalForceConverter';

/**
 * Generate MCT output from parsed Excel data
 */
export async function generateMCT(
  parseResult: ParseResult,
  options: ConversionOptions = { version: 2025, includeComments: true, validateInput: true },
  onProgress?: ProgressCallback
): Promise<ConversionResult> {
  const errors: string[] = [];
  const warnings: string[] = [];
  const mctLines: string[] = [];

  const version = options.version || 2025;
  const context = createConversionContext(version);
  const sheets = parseResult.sheets;

  try {
    // Progress tracking
    const report = (progress: number, message: string) => {
      if (onProgress) onProgress(progress, message);
    };

    report(0, '変換を開始します...');

    // Add header with version info
    mctLines.push(`; MIDAS/CIVIL NX ${version} Text Data File`);
    mctLines.push(`; Generated by ES-to-MIDAS Convertor (v1.1)`);
    mctLines.push(`*UNIT    ; Unit System`);
    mctLines.push(`; FORCE, LENGTH, HEAT, TEMPER`);
    mctLines.push(`${UNIT_SETTINGS.FORCE},${UNIT_SETTINGS.LENGTH},${UNIT_SETTINGS.HEAT},${UNIT_SETTINGS.TEMPERATURE}`);
    mctLines.push('');

    // Step 1: Parse numbered sections first (for section-material mapping)
    report(5, '数値断面を解析中...');
    if (hasSheet(sheets, SHEET_NAMES.NUMB_SECT)) {
      const numbSectData = getSheetDataForConversion(sheets, SHEET_NAMES.NUMB_SECT);
      parseNumbSectData(numbSectData, context);
    }

    // Step 2: Get spring double points (for node processing)
    let doublePointNodes = new Set<string>();
    if (hasSheet(sheets, SHEET_NAMES.ELEM_SPRING)) {
      const springData = getSheetDataForConversion(sheets, SHEET_NAMES.ELEM_SPRING);
      doublePointNodes = getSpringDoublePoints(springData);
    }

    // Step 3: Convert nodes
    report(10, '節点を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.NODE)) {
      const nodeData = getSheetDataForConversion(sheets, SHEET_NAMES.NODE);
      const nodeResult = convertNodes(
        nodeData.map(row => ({
          id: String(row[0]),
          x: Number(row[1]) || 0,
          y: Number(row[2]) || 0,
          z: Number(row[3]) || 0,
        })),
        context,
        doublePointNodes
      );
      mctLines.push(...nodeResult.mctLines);
      mctLines.push('');
    } else {
      errors.push('節点座標シートがありません');
      return { success: false, mctData: null, mctText: '', errors, warnings };
    }

    // Step 4: Collect section names from frame elements
    report(15, 'フレーム要素の断面を解析中...');
    const sectionNames = new Map<string, boolean>();
    let frameData: (string | number)[][] = [];
    if (hasSheet(sheets, SHEET_NAMES.FRAME)) {
      frameData = getSheetDataForConversion(sheets, SHEET_NAMES.FRAME);
      readFrameSectionNames(frameData, context);

      // Collect section names
      for (const row of frameData) {
        if (row[4]) sectionNames.set(String(row[4]), true);
        if (row[5]) sectionNames.set(String(row[5]), true);
      }
    }

    // Step 5: Read section element names
    if (hasSheet(sheets, SHEET_NAMES.SECT_ELEM)) {
      const sectElemData = getSheetDataForConversion(sheets, SHEET_NAMES.SECT_ELEM);
      for (const row of sectElemData) {
        if (row[0]) context.sect2Material.set(String(row[0]), String(row[1] || ''));
      }
    }

    // Step 6: Convert materials
    report(20, '材料を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.MATERIAL)) {
      const materialData = getSheetDataForConversion(sheets, SHEET_NAMES.MATERIAL);
      const matResult = convertMaterials(
        materialData.map(row => ({
          name: String(row[0]),
          type: String(row[1] || ''),
          category: String(row[2] || ''),
          strength: Number(row[3]) || 0,
          elasticModulus: Number(row[4]) || 0,
          density: Number(row[5]) || 0,
          thermalCoeff: Number(row[6]) || 0,
        })),
        context
      );
      mctLines.push(...matResult.mctLines);
      mctLines.push('');
    }

    // Step 7: Convert sections
    report(30, '断面を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.SECT)) {
      const sectData = getSheetDataForConversion(sheets, SHEET_NAMES.SECT);
      const sectYoung = new Map<string, number>();

      // Build section pairs from frame data
      const sectionPairs = new Map<string, string[]>();
      for (const row of frameData) {
        const iSect = String(row[4] || '');
        const jSect = String(row[5] || iSect);
        if (!iSect) continue;

        if (!sectionPairs.has(iSect)) {
          sectionPairs.set(iSect, []);
        }
        const existing = sectionPairs.get(iSect)!;
        if (!existing.includes(jSect)) {
          existing.push(jSect);
        }
      }

      const sectResult = convertSections(sectData, context, sectionPairs, sectYoung);
      if (sectResult.mctLinesValue.length > 6) {
        mctLines.push(...sectResult.mctLinesValue);
        mctLines.push('');
      }
      if (sectResult.mctLinesTapered.length > 10) {
        mctLines.push(...sectResult.mctLinesTapered);
        mctLines.push('');
      }
    }

    // Step 8: Convert plane sections
    if (hasSheet(sheets, SHEET_NAMES.PLN_SECT)) {
      const plnSectData = getSheetDataForConversion(sheets, SHEET_NAMES.PLN_SECT);
      const plnSectResult = convertPlnSections(plnSectData, context);
      if (plnSectResult.mctLines.length > 2) {
        mctLines.push(...plnSectResult.mctLines);
        mctLines.push('');
      }
    }

    // Step 9: Set element numbers (including rigid elements)
    report(40, '要素番号を設定中...');
    let rigidData: (string | number)[][] = [];
    if (hasSheet(sheets, SHEET_NAMES.RIGID)) {
      rigidData = readRigidData(getSheetDataForConversion(sheets, SHEET_NAMES.RIGID));
    }
    if (frameData.length > 0) {
      setElementNumbers(frameData, context, rigidData);
    }

    // Step 10: Convert frame elements
    report(45, 'フレーム要素を変換中...');
    if (frameData.length > 0) {
      const frameResult = convertFrames(frameData, context);
      mctLines.push(...frameResult.mctLines);
      mctLines.push('');
    }

    // Step 11: Convert plane elements
    if (hasSheet(sheets, SHEET_NAMES.PLANE_ELEMENT)) {
      const plnElmData = getSheetDataForConversion(sheets, SHEET_NAMES.PLANE_ELEMENT);
      const plnElmResult = convertPlaneElements(
        plnElmData,
        context,
        new Map() // plnSectMapping - would need to pass from PlnSect conversion
      );
      if (plnElmResult.mctLines.length > 2) {
        mctLines.push(...plnElmResult.mctLines);
        mctLines.push('');
      }
    }

    // Step 12: Convert rigid elements
    report(50, '剛体要素を変換中...');
    if (rigidData.length > 0) {
      const rigidResult = convertRigid(rigidData, context);
      if (rigidResult.mctLinesRigid.length > 2) {
        mctLines.push(...rigidResult.mctLinesRigid);
        mctLines.push('');
      }
    }

    // Step 13: Convert hinge properties and assignments
    report(60, 'ヒンジ特性を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.HINGE_PROP)) {
      // Get both zp and yp data
      const hingePropZpData = getSheetDataForConversion(sheets, SHEET_NAMES.HINGE_PROP);
      const hingePropYpData = hasSheet(sheets, 'HINGE_PROP_YP')
        ? getSheetDataForConversion(sheets, 'HINGE_PROP_YP')
        : [];
      const hingeMapping = readHingeProperties(hingePropZpData, context);

      if (hasSheet(sheets, SHEET_NAMES.HINGE_ASS)) {
        const hingeAssData = getSheetDataForConversion(sheets, SHEET_NAMES.HINGE_ASS);
        const hingeAssResult = convertHingeAssignments(hingeAssData, context, hingeMapping);

        const hingePropResult = convertHingeProperties(
          hingePropZpData,
          hingePropYpData,
          context,
          hingeAssResult.hystYp,
          hingeAssResult.hystZp,
          hingeAssResult.hingeElements
        );

        if (hingePropResult.mctLines.length > 2) {
          mctLines.push(...hingePropResult.mctLines);
          mctLines.push('');
        }

        // IHINGE-ASSIGN is generated by HingePropConverter (not HingeAssConverter)
        if (hingePropResult.mctLinesAssign.length > 2) {
          mctLines.push(...hingePropResult.mctLinesAssign);
          mctLines.push('');
        }
      }
    }

    // Step 14: Convert spring elements
    report(70, 'ばね要素を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.SPG_6COMP)) {
      const spg6Data = getSheetDataForConversion(sheets, SHEET_NAMES.SPG_6COMP);
      const spg6Result = parseSPG6CompData(spg6Data, context);

      if (hasSheet(sheets, SHEET_NAMES.ELEM_SPRING)) {
        const springElmData = getSheetDataForConversion(sheets, SHEET_NAMES.ELEM_SPRING);
        const springResult = convertSpringElements(springElmData, context, spg6Result.spg6CompMapping);
        if (springResult.mctLines.length > 2) {
          mctLines.push(...springResult.mctLines);
          mctLines.push('');
        }
      }

      // Convert symmetric springs
      if (hasSheet(sheets, SHEET_NAMES.SPG_ALL_SYM)) {
        const symData = getSheetDataForConversion(sheets, SHEET_NAMES.SPG_ALL_SYM);
        const symResult = convertSymmetricSprings(symData, context, spg6Result.spg6CompMapping);
        if (symResult.mctLines.length > 2) {
          mctLines.push(...symResult.mctLines);
          mctLines.push('');
        }
        // Add oil damper section if present (VBA VISCOUS-OIL-DAMPER)
        if (symResult.oilDamperLines.length > 0) {
          mctLines.push(...symResult.oilDamperLines);
          mctLines.push('');
        }
      }

      // Convert asymmetric springs
      if (hasSheet(sheets, SHEET_NAMES.SPG_ALL_ASYM)) {
        const asymData = getSheetDataForConversion(sheets, SHEET_NAMES.SPG_ALL_ASYM);
        const asymResult = convertAsymmetricSprings(asymData, context, spg6Result.spg6CompMapping);
        if (asymResult.mctLines.length > 2) {
          mctLines.push(...asymResult.mctLines);
          mctLines.push('');
        }
      }

      // Convert other springs
      if (hasSheet(sheets, SHEET_NAMES.SPG_ALL_OTHER)) {
        const otherData = getSheetDataForConversion(sheets, SHEET_NAMES.SPG_ALL_OTHER);
        const otherResult = convertOtherSprings(otherData, context, spg6Result.spg6CompMapping);
        if (otherResult.mctLines.length > 0) {
          mctLines.push(...otherResult.mctLines);
          mctLines.push('');
          if (otherResult.hasDamper) {
            warnings.push('BMR(CD)ダンパーはCIVIL NXの粘性ダンパーに変換されます。プロパティはデータ変換後に手動で変更してください。');
          }
        }
      }
    }

    // Step 15: Convert supports (fulcrum)
    report(80, '支点を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.FULCRUM)) {
      const fulcrumData = getSheetDataForConversion(sheets, SHEET_NAMES.FULCRUM);
      const fulcrumResult = convertFulcrum(fulcrumData, context);

      if (fulcrumResult.mctLinesConstraint.length > 2) {
        mctLines.push(...fulcrumResult.mctLinesConstraint);
        mctLines.push('');
      }

      if (fulcrumResult.mctLinesGSpring.length > 2) {
        mctLines.push(...fulcrumResult.mctLinesGSpring);
        mctLines.push('');

        // Convert fulcrum details
        if (hasSheet(sheets, SHEET_NAMES.FULC_DETAIL)) {
          const detailData = getSheetDataForConversion(sheets, SHEET_NAMES.FULC_DETAIL);
          const detailResult = convertFulcrumDetail(detailData, context, fulcrumResult.springTypeMapping);
          if (detailResult.mctLines.length > 2) {
            mctLines.push(...detailResult.mctLines);
            mctLines.push('');
          }
        }
      }
    }

    // Step 16: Convert nodal masses
    report(85, '節点質量を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.NODAL_MASS)) {
      const massData = getSheetDataForConversion(sheets, SHEET_NAMES.NODAL_MASS);
      const massResult = convertNodalMass(massData, context);
      if (massResult.mctLines.length > 2) {
        mctLines.push(...massResult.mctLines);
        mctLines.push('');
      }
    }

    // Step 17: Convert loads
    report(90, '荷重を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.LOAD)) {
      const loadData = getSheetDataForConversion(sheets, SHEET_NAMES.LOAD);
      const loadResult = convertLoads(loadData, context);

      if (loadResult.mctLinesLoadCase.length > 2) {
        mctLines.push(...loadResult.mctLinesLoadCase);
        mctLines.push('');
      }
      if (loadResult.mctLinesConLoad.length > 2) {
        mctLines.push(...loadResult.mctLinesConLoad);
        mctLines.push('');
      }
      if (loadResult.mctLinesSpDisp.length > 2) {
        mctLines.push(...loadResult.mctLinesSpDisp);
        mctLines.push('');
      }
      if (loadResult.mctLinesBeamLoad.length > 2) {
        mctLines.push(...loadResult.mctLinesBeamLoad);
        mctLines.push('');
      }
      if (loadResult.mctLinesElTemper.length > 2) {
        mctLines.push(...loadResult.mctLinesElTemper);
        mctLines.push('');
      }
    }

    // Step 18: Convert internal forces
    report(95, '内力を変換中...');
    if (hasSheet(sheets, SHEET_NAMES.INTERNAL_FORCE)) {
      const forceData = getSheetDataForConversion(sheets, SHEET_NAMES.INTERNAL_FORCE);
      const forceResult = convertInternalForce(forceData, context);
      if (forceResult.mctLines.length > 2) {
        mctLines.push(...forceResult.mctLines);
        mctLines.push('');
      }
    }

    // Add end marker
    mctLines.push('*ENDDATA');

    report(100, '変換完了');

    const mctText = mctLines.join('\n');

    return {
      success: true,
      mctData: null, // Full MCTData structure not needed for text output
      mctText,
      errors,
      warnings,
    };
  } catch (error) {
    errors.push(`変換エラー: ${error}`);
    return {
      success: false,
      mctData: null,
      mctText: '',
      errors,
      warnings,
    };
  }
}

/**
 * Download MCT text as file
 */
export function downloadMCT(mctText: string, filename: string = 'output.mct'): void {
  const blob = new Blob([mctText], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
